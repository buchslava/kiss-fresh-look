## Понятийная простота

Ну вот и дошла очередь до понятийной простоты.
Сразу хочу заметить, что в полном объеме раскрыть эту тему невозможно, поскольку в отличие от структурной простоты, тут неограниченная номенклатура проблем, а следовательно и неограниченное количество их решений.
Но несмотря на это я попытаюсь выделить наиболее характерные решения и на примерах выявить решения, которые будут полезны в решении разноплановых задач, а именно задач упрощения кода в понятийном аспекте.

Хочу заострить внимание на том, что в своих рассуждениях я не буду иметь в виду специфические задачи типа
построения UI, работу с базами данный, проектирование сложных многоуровневых систем итд. Причина проста:
решения проблем по вышеперечисленным тематикам и так прекрасно представлены в литературе, видеоуроках, 
научных работах... Одним словом, хорошо изучены. В отличие, кстати, от данной тематики.

Итак, с чем мы имеем дело? Понятно, что не с UI, СУБД и архитектурой многоуровневых системам. Там свои правила игры и толстые умные книги. Макромир, однако!

Тогда с чем же? Да просто с обыкновеннвми прикладными элементарными, казалось бы, задачками, коих в нашем повседневном коде великое множество. Можно сказать, что с микромиром. Именно из этих кирпичиков и состоят реальные проекты. Это может быть например, функционал для работы с бухгалтерской проводкой, части телекоммуникационного биллинга, компоненты обработки банковской или грузовой документации, управление поведением робота, ...

При работе с одним большим проектом я заметил такую специфику: классы и методы названы адекватно, их соподчиненность тоже вопросов не вызывала. И все было хорошо, пока не пришлось начать разбирать по косточкам сам код методов. И когда я залез "в кишки" - код самих методов, стало понятно - что ничего то и непонятно с этим проектом. То есть с макромиром - вшешний порядок, а с микромиром - беда.

Именно такую ситуацию я и считаю наиболее опасной и посвящаю данную работу борьбе с ней.

На самом деле, этот самый микромир в каком-то смысле более важен чем макромир с его архитектурными хитросплетениями. И при этом он менее заметен. Микро же! Рассуждения просты: нельзя построить качественный дом их некачественных кирпичей.

В чем же тут проблема? Казалось бери и пиши. Тем более что backlog готов, заказчик дружелюбен и коллеги умны.
Но нет... На практике часто получается так, что при практически идеальных условиях с проектами возникают проблемы в плане 
простоты кода. Что уж тогда говорить про не совсем или совсем НЕ идеальные услоивия, когда ТЗ противоречиво, времени мало,
планирование и контроль качества отсутствуют.

А что если проект на миллионы строк кода и на годы. Как раз вот тут код и становится тем краеугольным камнем, от
которого и зависит - взлетит проект или пополнит и так уже без того объемное виртуальное кладбище. Сотни строк плохого кода исправить можно, а миллионы - НЕТ: не помогут ни аджайл ни скрам ни код ревью ни гуру, ни уйма времени. Вы даже не поверите, но и обильные финансовые вливания тоже не помогут... 

А может вообще лучше ничего не исправлять, а писать сразу просто. Фантастика? Думаю, что нет...

Хватит лирики, перейдем к примеру. В качестве самого простого прикладного примера я выбрал "Светофор". Итак задача. Написать программу, выдающую сигналы цвета (красный - желтый - зеленый - желтый - ...) во времени. Причем интервал для желтого меньше интервала для красного и зеленого. Плюс дополнительный функционал так радующий пешехода и раздражающий водителя. Это возможность быстрого переключения на зеленый свет по требованию. Наверное, более детальнаое описание этого функционала не требуется...

Для начала напишем неполный минимальный пример:

`/00sketch.js`
```javascript
const lights = ['red', 'yellow', 'green', 'yellow'];

const timeout = (currentLight) => {
  const nextLight = currentLight + 1 < lights.length ? currentLight + 1 : 0;
  const timeoutValue = nextLight === 1 || nextLight === 3 ? 500 : 3000;

  setTimeout(() => {
    console.log(lights[currentLight], new Date());

    timeout(nextLight);
  }, timeoutValue);
}

timeout(0);
```

Поясню.

Вот минимальная последовательность состояний с учетом нужного порядка:
```javascript
const lights = ['red', 'yellow', 'green', 'yellow'];
```
Те красный(0) - желтый(1) - зеленый(2) - желтый(3) ... итд.

Далее определим функцию `timeout`, в которой и будет содержаться логика работы светофора.

```javascript
// на вход поступает текущий свет, определяющийся как соответствующая позиция
// массива lights
const timeout = (currentLight) => {
  // определим следующий свет как текущий свет+1, те следующий в массиве lights
  // или 0 - (те с начала) если достигнут конец массива
  const nextLight = currentLight + 1 < lights.length ? currentLight + 1 : 0;
  // определим значение timeout:
  // если текущий свет желтый - то 500ms, а иначе 3sec
  const timeoutValue = nextLight === 1 || nextLight === 3 ? 500 : 3000;

  // установим таймаут
  setTimeout(() => {
    // а в нем выведем на экран текущий свет
    console.log(lights[currentLight], new Date());

    // и после этого рекурсивно вызовем эту же функцию, 
    // только уже новым значением света
    timeout(nextLight);
  }, timeoutValue);
}
```
Ну и наконец, сам запуск:

```javascript
timeout(0);
```

Обратите внимание на значение парамерта функции: 0 - красный. Тут мог быть и любой другой цвет от 0 до 3.

Запустим: `node ./00sketch.js` и после некоторого времени работы и Ctrl+C получим примерно такой результат:
```
red 2017-09-24T16:30:35.180Z
yellow 2017-09-24T16:30:38.190Z
green 2017-09-24T16:30:38.692Z
yellow 2017-09-24T16:30:41.697Z
red 2017-09-24T16:30:42.199Z
yellow 2017-09-24T16:30:45.204Z
green 2017-09-24T16:30:45.706Z
yellow 2017-09-24T16:30:48.712Z
red 2017-09-24T16:30:49.212Z
yellow 2017-09-24T16:30:52.218Z
green 2017-09-24T16:30:52.720Z
yellow 2017-09-24T16:30:55.724Z
red 2017-09-24T16:30:56.226Z
yellow 2017-09-24T16:30:59.226Z
green 2017-09-24T16:30:59.728Z
``` 

Теперь самое время добавить обещанный функционал "Зелёный по требованию": `01simple.js`

```javascript
const stdin = process.stdin;

stdin.setRawMode(true);
stdin.resume();
stdin.setEncoding('utf8');

const lights = ['red', 'yellow', 'green', 'yellow'];

let globalCurrentLight = 0;
let globalTimeout = null;

const timeout = (currentLight) => {
  const nextLight = currentLight + 1 < lights.length ? currentLight + 1 : 0;
  const timeoutValue = nextLight === 0 || nextLight === 2 ? 2000 : 5000;

  globalCurrentLight = currentLight;

  console.log(lights[currentLight], new Date());

  globalTimeout = setTimeout(() => {
      timeout(nextLight);
  }, timeoutValue);
};

stdin.on('data', key => {
  if ( key === '\u0003' ) {
    process.exit();
  }

  if (globalCurrentLight === 0 || globalCurrentLight === 3) {
    clearTimeout(globalTimeout);

    timeout(1);
  }
});

timeout(0);
```

Хоть и данный пример не был радикально изменен по-сравнению с предыдущим, все же требуются небольшие пояснения.
Итак, код пусть вас не смущает
```javascript
const stdin = process.stdin;

stdin.setRawMode(true);
stdin.resume();
stdin.setEncoding('utf8');
```
примете его просто как данное.

А вот этот код уже куда поважнее для нашей задачи:

```javascript
let globalCurrentLight = 0;
let globalTimeout = null;
```

Все дело в том, что в предыдущем примере текущее значение света и таймаут были инкапсулированы внутри функции `timeout`. А в данном примере эти параметры надо менять извне. И вот поэтому и были добавлены две глобальные переменные. Тут опытному читателю время возмутиться и высказать претензии, кстати, совершенно справедливые... Немного терпения, дорогой читатель! Во-первых я хочу показать не только как надо писать код, но и как этого делать НЕ надо. Во-вторых хочется продемонстрировать полный процесс эволюции: от простого и неаккуратного к сложному и гармоничному. Ну а в-третьих - цель этой работы - больше чем просто написание кода. Тут речь пойдет о приобретении особого мировоззрения: не больше и не меньше.

Итак, в функции `timeout` изменений немного:
```javascript
const timeout = (currentLight) => {
  const nextLight = currentLight + 1 < lights.length ? currentLight + 1 : 0;
  const timeoutValue = nextLight === 0 || nextLight === 2 ? 2000 : 5000;

  // сохраним глобальное состояние
  globalCurrentLight = currentLight;

  console.log(lights[currentLight], new Date());

  globalTimeout = setTimeout(() => {
      timeout(nextLight);
  }, timeoutValue);
};
```

А вот с новым кодом будет веселей:

```javascript
// читаем поток ввода: клавиатуру
stdin.on('data', key => {
  // если это Ctrl+C
  if ( key === '\u0003' ) {
    // завершаем программу 
    process.exit();
  }

  // если это любая другая клавиша или комбинация
  // и при этом текущий свет красный или желтый перед красным
  if (globalCurrentLight === 0 || globalCurrentLight === 3) {
    // отменяем текуший таймаут
    clearTimeout(globalTimeout);

    // и стартуем процесс с желтого света, только того, который перед зеленым
    timeout(1);
  }
});
```

Запустим: `node ./01simple.js` и после некоторого времени работы и Ctrl+C получим примерно такой результат:
```
red 2017-09-24T19:58:46.247Z
yellow 2017-09-24T19:58:51.255Z
green 2017-09-24T19:58:53.256Z
yellow 2017-09-24T19:58:58.262Z
red 2017-09-24T19:59:00.268Z
yellow 2017-09-24T19:59:00.782Z
green 2017-09-24T19:59:02.787Z
yellow 2017-09-24T19:59:07.793Z
yellow 2017-09-24T19:59:08.402Z
green 2017-09-24T19:59:10.408Z
yellow 2017-09-24T19:59:15.414Z
red 2017-09-24T19:59:17.419Z
yellow 2017-09-24T19:59:17.940Z
green 2017-09-24T19:59:19.942Z
```

На приведенном выше результате видно, где была нажата кнопка "Зеленый по требованию". Это где желтый свет идет подряд и интервал между красным и желтым менее 3-х секунд.

Теперь самое время критически взглануть на `01simple.js`. Главная проблема этого кода - глобальные состояния. Такое недопустимо даже в рамках студенческих лабораторных работ. Вторая проблема менее очевидна для неподготовленного разработчика. Это слабая структурированность кода. Да, да - это отсутствие той самой структурной простоты, о которую я упоминал в самом начале. Дело в том, что это нам, читателям, ясно что речь идет о светофоре. А если показать этот код другим разработчикам? Поймут? Нет! В лучшем случае догадаются опираясь на личный опыт. И как тут не вспомнить о эгоцентричности в восприятии простоты!!!

Итак, встречайте `02oop.js`
```javascript
const stdin = process.stdin;

stdin.setRawMode(true);
stdin.resume();
stdin.setEncoding('utf8');

class TrafficLight {
  constructor() {
    this.RED = Symbol('RED');
    this.YELLOW = Symbol('YELLOW');
    this.GREEN = Symbol('GREEN');

    this.lights = [this.RED, this.YELLOW, this.GREEN, this.YELLOW];
    this.currentLight = 0;
    this.timeoutId = null;
  }

  process(currentLight) {
    this.currentLight = currentLight;

    const nextLight = this.currentLight + 1 < this.lights.length ? this.currentLight + 1 : 0;
    const timeoutValue = nextLight === 0 || nextLight === 2 ? 2000 : 5000;

    console.log(String(this.lights[currentLight]), new Date());

    clearTimeout(this.globalTimeout);

    this.globalTimeout = setTimeout(() => {
        this.process(nextLight);
    }, timeoutValue);
  }

  greenRequest() {
    if (this.currentLight === 0 || this.currentLight === 3) {
      clearTimeout(this.globalTimeout);

      this.process(1);
    }
  }
}

const trafficLight = new TrafficLight();

trafficLight.process(0);

stdin.on('data', key => {
  if ( key === '\u0003' ) {
    process.exit();
  }

  trafficLight.greenRequest();
});
```

Как вы уже заметили, принципиальное отличие данного примера от всех предыдущих заключается в использовании ООП. В данном случае это нужно прежде всего для инкапсуляции понятия "Светофор" и как следствия - избавления от глобальных состояний.

Больше - в коментариях.

```javascript
// тут без изменений
const stdin = process.stdin;

stdin.setRawMode(true);
stdin.resume();
stdin.setEncoding('utf8');

// теперь основа всег - класс
class TrafficLight {
  constructor() {
    // определим константы света как символы - так надежнее
    this.RED = Symbol('RED');
    this.YELLOW = Symbol('YELLOW');
    this.GREEN = Symbol('GREEN');

    this.lights = [this.RED, this.YELLOW, this.GREEN, this.YELLOW];
    // currentLight и timeoutId - теперь члены класса
    this.currentLight = 0;
    this.timeoutId = null;
  }

  // это метод, описывающий основной процесс
  // аналог функции timeout в предыдущий примерах
  // по прежнему на вход получает текущий свет как локальную переменную
  process(currentLight) {
    // установим текущий свет
    this.currentLight = currentLight;

    const nextLight = this.currentLight + 1 < this.lights.length ? this.currentLight + 1 : 0;
    const timeoutValue = nextLight === 0 || nextLight === 2 ? 2000 : 5000;

    // выведем значение
    console.log(String(this.lights[currentLight]), new Date());

    // очистим текущий timeout
    clearTimeout(this.globalTimeout);

    // установим текущий timeout
    this.globalTimeout = setTimeout(() => {
        // и рекурсивнр вызовем в нем process по анагогии с предыдущими примерами
        this.process(nextLight);
    }, timeoutValue);
  }

  // этот метод инкапсулирует логику "Зеленый свет по запросу"
  greenRequest() {
    // логика аналогичная предыдущим примерам
    // за исключением использования переменных класса
    if (this.currentLight === 0 || this.currentLight === 3) {
      clearTimeout(this.globalTimeout);

      this.process(1);
    }
  }
}

// создадим экземпляр класса
const trafficLight = new TrafficLight();

// и запустим основной процесс
trafficLight.process(0);

// тут без изменений
stdin.on('data', key => {
  if ( key === '\u0003' ) {
    process.exit();
  }

  // "Зеленый по требованию" уже инкапсулирован в классе
  // Это важное улучшение!
  trafficLight.greenRequest();
});
```

Круто? Да, но только для начинающего разработчика. Подобной техникой рефакторинга Америки я не открыл. Кода, написанного в подобном стиле (и даже чище) - великое множество.

А теперь по сложившейся традиции давайте взглянем критически и на этот код. Он конечно же читабельнее предыдущих, но правда и объемнее. Но как я уже ранее говорил - минимализм не всегда друг простоты, а иногда даже и враг.

Вот на этом месте я не могу дать гарантии, что большинство, как принято говорить, middle разработчиков скажут что этот код плох. Этим я и объясняю засилие подобных подходов при изложении идей в проектах. 

Я не ошибся... Именно изложение идей, а не написание кода. И в этом то и состоит главная проблема современной разработки. Заказчик дал идею. Начало хорошее: обсуждение - планирование - дизайн - архитектурное решение. Пока хорошо. Начинаем кодить, потом пытаемя прочесть... А что прочесть? Код конечно! А где же идея? А её уже нет, мы ее благополучно уничтожили своими руками, как собственно и проект. Да ещё как изощренно: при помощи паттернов программирования, ООП. А ведь заказчик заплатил деньги ИМЕННО за реализацию ИДЕИ! 

Поэтому хватит писать код!!!

Давайте излагать идеи при помощи кода. Тем более, что в истории ИТ такие попытки уже были. Самая яркая из них, на мой взгляд это технология Smalltalk. Почему она не стала мейнстримом - предмет исследования ученых. В любом случае наш код должен быть больше, чем human readable (human readable я лично считаю ловушкой: looks good != to be good), я бы сказал что human oriented. Согласитесь, это две большие разницы! Прочесть - это одно, а понять, а тем более понять быстро (давайте вспомним о зоне комфортного кодирования) - это уже совсем иной уровень.

Вот с этого самого уровня и начинается понятийная простота. Как вы уже наверное поняли, элементарными средстваими она не достигается. Тут мало одной декомпозиции: нужен осмысленный подход. Его объясление начну немного издалека. 

Дело в том, что практически любому человеку проще:

 * делать ОДНО дело в ОДИН момент времени
 * оперировать атомарными, а не комплексными понятиями
 * оперировать комплексным понятием с прозрачными, а не размытыми связями между отдельными его компонентами 
 * полагаться на логическое, а не механическое запоминание

Не думаю, что надо продолжать этот список: вектор дальнейший рассуждений ясен.

Позволю себе еще ряд неочевидных, но на мой взгляд важных рассуждений. Коль уж мы стремимся к human oriented коду, то именно его, те код, надо приближать как максимум к естественному человеческому мышлению или как минимум, к естественному человеческому языку, а не наоборот. Кстати, подстраиванием нашего мышления под код мы занимаемся сейчас в нашей повседневной разработке. Борьбой с этим злом мы с вами сейчаси займемся. 

И вот какие тезисы могут тут оказаться полезными:
 
 * человек находится во временных рамках
 * человек мыслит образами
 * образы чаще всего представляют собой комбинацию из предметов и действий над ними
 * человек постоянно ведет обмен информацией при непосредственном участии образов
 * универсальная единица обмена информацией - ИСТРОИЯ
 * экран - это максимальная часть кода, которая воспринимается разработчиком единовременно (я об этом говорил ранее)
 * образ/история должен должен стремится к размещению на одном экране (следствие из вышесказанного)
 * метод-класс, да и вообще обособленный именованый фрагмент кода, должнен решать только ОДНУ задачу и относиться к одной предметной области

Попробуем воплотить эти тезисы в жизнь. Для этого вернемся к `02oop.js`. Позволю себе его повторить:

`02oop.js`
```javascript
const stdin = process.stdin;

stdin.setRawMode(true);
stdin.resume();
stdin.setEncoding('utf8');

class TrafficLight {
  constructor() {
    this.RED = Symbol('RED');
    this.YELLOW = Symbol('YELLOW');
    this.GREEN = Symbol('GREEN');

    this.lights = [this.RED, this.YELLOW, this.GREEN, this.YELLOW];
    this.currentLight = 0;
    this.timeoutId = null;
  }

  process(currentLight) {
    this.currentLight = currentLight;

    const nextLight = this.currentLight + 1 < this.lights.length ? this.currentLight + 1 : 0;
    const timeoutValue = nextLight === 0 || nextLight === 2 ? 2000 : 5000;

    console.log(String(this.lights[currentLight]), new Date());

    clearTimeout(this.globalTimeout);

    this.globalTimeout = setTimeout(() => {
        this.process(nextLight);
    }, timeoutValue);
  }

  greenRequest() {
    if (this.currentLight === 0 || this.currentLight === 3) {
      clearTimeout(this.globalTimeout);

      this.process(1);
    }
  }
}

const trafficLight = new TrafficLight();

trafficLight.process(0);

stdin.on('data', key => {
  if ( key === '\u0003' ) {
    process.exit();
  }

  trafficLight.greenRequest();
});
```

Предлагаю ответить на два вопроса:

 1. Сколько задач решает метод `process`?
 2. Сколько предметных областей включает в себя класс `TrafficLight`?
 
Давайте подумаем вместе...

Ответ на первый вопрос. Может показаться, что данный метод решает одну задачу... Ну он же метод, в конце концов. Ответ неправильный. Две? - работа со светофором и таймером? Уже теплее, но неконкретно. Кто больше???

На самом деле 4! Удивлены?

Так вот, метод `process` решает такие задачи:

 1. вычисление следующего света: `const nextLight = ...`
 2. вычисление значения таймаута: `const timeoutValue = ...`
 3. вывод на экран значения света: `console.log(String(this.lights[currentLight]), new Date());`
 4. работа с таймером: `clearTimeout(this.globalTimeout); this.globalTimeout = setTimeout(() => { ...`

Не слишком ли много для одного метода? Многовато, однако...

Ответ на второй вопрос. Тут проще: из ответа на первый вопрос можно сделать вывод, что две: светофор и таймер.

Итак, очевидно, что одним классом мы уже не отделаемся, если хотим отрефакторить класс `TrafficLight` правильно. А сколько классов необходимо? Давайде вновь поразмыслим. 

Проведем небольшой экскурс в тайны человеческого разума и попытаемся ответить на такой вопрос. Как человек обменивается информацией? Ответ очевиден - вербально, те при помощи произвольного языка: нашего естественного человеческого языка, используемого ежедневно. Что мы делаем чаще всего для того, чтобы передать информацию вербально? Правильно, рассказываем друг другу ИСТОРИИ. А без чего невозможна минимальная история? Без ПРЕДМЕТА и ДЕЙСТВИЯ, связанного с этим предметом. Запомним эту идею, она нам скоро очень пригодится! 

Вернемся к первоначальной задаче. Так сколько классов надо для описания Светофора? Давайте начинать считать.
Функционал светофора - раз. 
Функционал рекурсивного таймера - два.

B это все? Наверное нет: в такой конструкции светофор ничего не знает о таймере, а таймер - о светофоре. И тут уже опытный разработчик скажет: Ну постойте, все ж ведь просто: эта проблема рещается при помощи DI! Заинжектим таймер в светофор!

Звучит заманчиво, да и код возможно будет красив. Но вот читабелен ли? Я думаю что нет, и вот почему. Дело в том, что Светофор это Светофор, простите за тавтологию... Он просто предмет. А таймер - это процесс и он просто процесс. Скрещивание предмета с действием противоречит нашей человеческой вербальной сущности. Давайте по-честному: предмет - это предмет, а действие - это действие. В обыденной практике мы НИКОГДА, я подчеркиваю НИКОГДА не смешиваем эти понятия.

А то получается такая картина: предмето-действие посредством своего действия порождает другое предмето-действие, которое своим действием меняет предмет из породившего его предмето-действия через систему event-ов. Вот так мы сейчас и пишем код. Ужасы генной инженерии нервно курят в сторонке!!!

Вот именно тут и кроется одна из глобальных проблем при работе с кодом. Мы пытаемся создавать искусственные вербальные (а ведь язык программирования - это тоже язык) конструкции не выходя из зоны нашего естественного языка, мышления и ментальности. И создаем, и довольно успешно... Но вот только обратно воспроизвести не можем потому, что они никак не связаны с реальным миром и поэтому нежизнеспособны. Нежизнеспособны, я не ошибся... Это совершенно серьезно: тут кроется глубокий смысл. Правильный код ничем не должен отличаеться от литературного произведения. Он - такая же передача человеческих мыслей, только более точная и формальная.

Скажу больше, когда мы создаем иссусственные языковые конструкции на самом деле нам только кажется, что мы их понимаем, тк период их запоминания (те комфортной работы с ними) - кратковременный отрезок времени, а дальше - только забвение. А если и запоминаем в силу хорошей памяти - то делаем хуже себе и коллегам с менее развитой механической памятью, так как в этом случае создается только ИЛЛЮЗИЯ простоты для автора и такая ситуация - это потенциальный источник конфликта в коллективе. И как тут не вспомнить о темпоральности простоты и о негативной роли механической памяти! 

Итак, давайте кроме функционала светофора и рекурсивного таймера создадим ещё и Историю светофора, то есть расскажем о нем окружающим. Этот функционал и должен объединить функционал светофора (далее объект) с фуникионалом рекурсивного таймера (далее процесс). 

Можно провести аналогию (правда очень грубую; да простят меня филологи!): Объект - подлежащее, Процесс - мказуемое, а История - предложение, передающее смысл.

Итак, реализуем Процесс, Объект и Историю и сразу с коментириями

`03pos.js`
```javascript
const stdin = process.stdin;

stdin.setRawMode(true);
stdin.resume();
stdin.setEncoding('utf8');

// класс Процесса
// рекурсивный таймер
class RecursiveTimer {
  constructor(context) {
    this.context = context;
  }

  // медод, реализующий остановку процесса
  stop() {
    clearTimeout(this.globalTimeout);
  }

  // метод, реализующий сам рекурсивный процесс
  // на вход получает:
  // value - значение как результат-операнд
  // actionFun - функция для получения значения-операнда
  // getNextTimeoutFun - функция для вычисления следующего таймаута
  // getNextValueFun - функция для вычисления следующего значения операнда
  process(value, actionFun, getNextTimeoutFun, getNextValueFun) {
    // привяжем значения с данному экземпляру класса: специфика Javascript
    const action = actionFun.bind(this.context);
    const getNextTimeout = getNextTimeoutFun.bind(this.context);
    const getNextValue = getNextValueFun.bind(this.context);

    // выполним само действие, ради циклического выполнения которого
    // этот рекурсивный таймер и создавался
    // те вызовем `actionFun` с параметром `value`
    action(value);

    // вычислим следующее значение таймаута
    const timeout = getNextTimeout();
    // вычислим следующее значение-операнд
    const nextValue = getNextValue();

    clearTimeout(this.globalTimeout);

    // вызовем еще раз самого себя, но на этот раз уже новыми значениями   
    this.globalTimeout = setTimeout(() => {
      this.process(nextValue, actionFun, getNextTimeoutFun, getNextValueFun);
    }, timeout);
  }
}

// определим цепочку позиций-состояний для цветов
// красный свет сверофора
const RED_STATE = 0;
// желтый свет сверофора перед зеленым (и после красного)
const YELLLOW_BEFORE_GREEN_STATE = 1;
// зеленый свет сверофора
const GREEN_STATE = 2;
// желтый свет сверофора после зеленого (и перед красным)
const YELLOW_AFTER_GREEN_STATE = 3;

// класс, описывающий Объект
class TrafficLight {
  constructor() {
    // константы цветов
    this.RED = Symbol('RED');
    this.YELLOW = Symbol('YELLOW');
    this.GREEN = Symbol('GREEN');

    // цепочка позиций-состояний светофора
    this.flow = [this.RED, this.YELLOW, this.GREEN, this.YELLOW];
    this.current = 0;
  }

  // метод, который выводит на экран значение света
  // и передается как `actionFun` в `RecursiveTimer`те наш Процесс
  setAndShowLight(newLightValue) {
    // текущее значение света (позиция-состояние) хранить в объекте
    this.current = newLightValue;

    // собственно вывод
    console.log(String(this.flow[this.current]), new Date());
  }

  // метод, который вычисляет следующее значение света
  // и передается как `getNextLightFun` в `RecursiveTimer`те наш Процесс
  getNextLight() {
    // если свет, следующий за текущим меньше к-ва позиций-состояний,
    // тогда текущий свет (позиция-состояние) увеличим на один
    // а инече - к самому началу цепочек состояний (те красному свету)
    return this.current + 1 < this.flow.length ? this.current + 1 : 0;
  }

  // метод, который вычисляет следующее значение таймаута
  // и передается как `getNextTimeoutFun` в `RecursiveTimer`те наш Процесс
  getNextTimeout() {
    const nextLight = this.getNextLight();

    // если следующее значение света красное или зеленое, те сейчас у нас желтый -
    // установить таймаут 2сек, иначе - 5сек
    // иными словами, продолжительность свечения желтого света - 2сек,
    // а остальных - 5сек
    return nextLight === RED_STATE || nextLight === GREEN_STATE ? 2000 : 5000;
  }

  // мелод, отвечающий на вопрос - а имеем ли мы право на запрос зеленого света
  isRedOrYellowAfterGreen() {
    return this.current === RED_STATE || this.current === YELLOW_AFTER_GREEN_STATE;
  }
}

// класс - история
// главная задача этого класса - осуществить связь
// между общим Процессом и конкретным Объектом
// то есть, рассказать!
class TrafficLightStory {
  constructor() {
    // поэтому нам нужны
    // - Объект
    this.trafficLight = new TrafficLight();
    // - и Процесс
    // причем объект передается Процессу ИСКЛЮЧИТЕЛЬНО в качестве контекста
    // (см. функцию bind)
    this.recursiveTimer = new RecursiveTimer(this.trafficLight);
  }

  // точка входа - главный метод во всей конструкции светофора
  // он то и расскажет нам все!
  tell() {
    // итак, запускаем Процесс и передаем ему:
    this.recursiveTimer.process(
      // начельное значение света
      RED_STATE,
      // функцию для отображение и хранения света
      this.trafficLight.setAndShowLight,
      // функцию для вычисления таймаута
      this.trafficLight.getNextTimeout,
      // функцию для вычисления значения следующего света
      this.trafficLight.getNextLight);
    // тут стоит еще раз отметить, что Процесс НЕ знает ничего
    // про специфику светофора, а вот Объект выполнен, как вы уже заметили
    // в полном соответствии с требованиями Процесса (см аргументы метода `process`) 
  }

  // метод, реализующий логику "Зеленый по требованию"
  requestGreen() {
    // имеет смысл, только если текущий свет
    // краснуй или желтый после зеленого (те перед красным)
    if (this.trafficLight.isRedOrYellowAfterGreen()) {
      // останавилваем Процесс
      this.recursiveTimer.stop();
      // и стартуем его заново с зеленого света
      this.recursiveTimer.process(
        YELLLOW_BEFORE_GREEN_STATE,
        this.trafficLight.setAndShowLight,
        this.trafficLight.getNextTimeout,
        this.trafficLight.getNextLight);
    }
  }
}

// создаем историю
const trafficLightStory = new TrafficLightStory();
// рассказываем ее
trafficLightStory.tell();

// ловим события клавиатуры 
stdin.on('data', key => {
  // если Ctrl+C - выходим из программы
  if ( key === '\u0003' ) {
    process.exit();
  }

  // а иначе, те при нажатии любой клавиши
  // обращаемся к истории и просим зеленый свет
  trafficLightStory.requestGreen();
});
```

Безусловно, наша программа стала значительно больше по сревнению с ее первоначальной версией, но, я надеюсь, немного читабельней. Скажу более: и такой код не редкость в нашей практике. А так ли он хорош? Давайте проанализируем его достоинства и недостатки.

Прежде всего он стал больше за счет жесткого выделения процесса (Рекурсивного таймера), который, как было указано ранее к самому Светофору прямого отношения НЕ имеет. Тут мы пожертвовали минимализмом и приобрели некоторую дополнительную читабельность кода. Это уже хорошо. Но на этом пока все... Дальше одни недостатки. Что касается Процесса: передача всех параметров при каждом рекурсивном вызове - это некрасиво! Можно, например запутаться в их порядке. Все-таки проще хранить эти данные в классе. И как следствие, метод `process` имеет слишком много аргументов, что приводит к плохой читаемости и дурно влияет на Историю. По этой причине Истрия выглядит не как История, а как часть доски на лекции по высшей математике. Метод `tell` не выглядит даже human readable. А наша же цель - сделать код похожим на литературное произведение, притом литературное произведение - понятное широким массам. Что же касается Объекта - то с ним уже полный порядок. Он с одной стороны минималистичен, а с другой - в полной мере описывает требуемый функционал. 

Также еще нужно вспомнить о структурной простоте: ведь наш файл `03pos.js` уже далеко вышел за пределы одного экрана, а следовательно есть необходимость поделить наш код на множество файлов, в разумных пределах, разумеется. 

Итак, попробуем устранить вышеописанные недостатки с попутными коментариями на изменения.

### Константы
`04pos/constants.js`
```javascript
module.exports = {
  RED_STATE: 0,
  YELLLOW_BEFORE_GREEN_STATE: 1,
  GREEN_STATE: 2,
  YELLOW_AFTER_GREEN_STATE: 3
};
```

### Рекурсивный таймер
`04pos/recursive-timer.js`
```javascript
module.exports = class RecursiveTimer {
  constructor(context) {
    this.context = context;
    // новое поле класса - initialValue - начальное значение
    this.initialValue = null;
    // новое поле класса - fixedTimeout - на тот случай, если у нас
    // всегда постоянный таймаут
    this.fixedTimeout = null;
  }

  // тут мы добавим четыре новых метода
  // обратите внимание, что они оформлены по правилам паттерна Builder
  // те возвращают this; это важно для их постедующего использования в Истории

  // метод для установки начального значения
  withInitialValue(initialValue) {
    this.initialValue = initialValue;

    return this;
  }

  // метод для установки функции, вылисляющей значение таймаута
  // и расчитан на единственный вызов перед запуском Процесса
  withCustomTimeout(getNextTimeoutFun) {
    // биндинг - один раз, как и обещал:)
    this.getNextTimeout = getNextTimeoutFun.bind(this.context);

    return this;
  }

  // метод для установки постоянного значения таймаута
  withFixedTimeout(fixedTimeout) {
    this.fixedTimeout = fixedTimeout;

    return this;
  }

  // метод для установки функции, вылисляющей значения
  // и расчитан на единственный вызов перед запуском Процесса
  calculateNextValue(getNextValueFun) {
    this.getNextValue = getNextValueFun.bind(this.context);

    return this;
  }

  // проверка правильности параметров
  checkConstraints() {
    // какой-либо таймаут должен быть установлен
    // вычисляемый функцией (getNextTimeout) или четкий (fixedTimeout)
    if (!(this.getNextTimeout || this.fixedTimeout)) {
      throw Error('Timeout is confusing or missing!');
    }

    // функция для вычисления следующего значения должна быть установлена
    if (!this.getNextValue) {
      throw Error('Function for value calculating is missing!');
    }
  }

  // метод, реализующий старт процесса и принимающий функнию
  // запускаемую рекурсивно
  // сам метод не вызывается рекурсивно и вызывается в начале Процесса
  start(actionFun) {
    // проверим правильность
    this.checkConstraints();

    // сохраним правильную (привязанную к контексту функцию action)
    this.action = actionFun.bind(this.context);

    const nextTimeout = this.fixedTimeout || this.getNextTimeout();
    const nextValue = this.getNextValue ? this.getNextValue() : null;
 
    // основные действия
    this.action(this.initialValue);

    // запускаем таймер
    this.globalTimeout = setTimeout(() => {
      // и вызываем process
      this.process(nextValue);
    }, nextTimeout);
  }

  restartFrom(value) {
    clearTimeout(this.globalTimeout);

    this.process(value);
  }

  // метод, выполняющий основную работу и вызываемый рекурсивно
  process(value) {
    // отработать основные действия 
    this.action(value);

    // посчитать следующие значение и таймаут
    const timeout = this.fixedTimeout || this.getNextTimeout();
    const nextValue = this.getNextValue ? this.getNextValue() : null;

    clearTimeout(this.globalTimeout);
    
    // сделать рекурсивный вызов по таймеру
    this.globalTimeout = setTimeout(() => {
      this.process(nextValue);
    }, timeout);
  }
}
```

# Объект светофоа
`04pos/traffic-light.js`
```javascript
const constants = require('./constants');

module.exports = class TrafficLight {
  constructor() {
    this.RED = Symbol('RED');
    this.YELLOW = Symbol('YELLOW');
    this.GREEN = Symbol('GREEN');

    this.flow = [this.RED, this.YELLOW, this.GREEN, this.YELLOW];
    this.current = 0;
  }

  setAndShowLight(newLightValue) {
    this.current = newLightValue;

    console.log(String(this.flow[this.current]), new Date());
  }

  getNextLight() {
    return this.current + 1 < this.flow.length ? this.current + 1 : 0;
  }

  getNextTimeout() {
    const nextLight = this.getNextLight();

    return nextLight === RED_STATE || nextLight === GREEN_STATE ? 2000 : 5000;
  }

  isRedOrYellowAfterGreen() {
    return this.current === RED_STATE || this.current === YELLOW_AFTER_GREEN_STATE;
  }
}
```

### История светофора
`04pos/traffic-light-story.js`
```javascript
const constants = require('./constants');
const TrafficLight = require('./traffic-light');
const RecursiveTimer = require('./recursive-timer');

module.exports = class TrafficLightStory {
  constructor() {
    this.trafficLight = new TrafficLight();
    this.recursiveTimer = new RecursiveTimer(this.trafficLight);
  }

  tell() {
    // вместо неуклюжего вызова метода `process` с множеством параметров
    // воспользуемся паттерном Builder и сформируем легко читаемую
    // цепочку вызовов методов вызываемых в интуитивно понятном порядке
    // и представляющую собой законченное действие над Светофором
    // думаю, что далее комментарии уже излишни 
    this.recursiveTimer
      .withInitialValue(constants.RED_STATE)
      .withCustomTimeout(this.trafficLight.getNextTimeout)
      .calculateNextValue(this.trafficLight.getNextLight)
      .start(this.trafficLight.setAndShowLight);
  }

  requestGreen() {
    if (this.trafficLight.isRedOrYellowAfterGreen()) {
      // тут только одно изменение: так как все необходимые параметры
      // уже храняться в нашем процессе
      // мы оперируем данными, относящимися только к ДАННОМУ случаю
      this.recursiveTimer.restartFrom(constants.YELLLOW_BEFORE_GREEN_STATE);
    }
  }
}
```

### Запуск программы: старт Истории
`04pos/index.js`
```javascript
//  тут без изменений
const stdin = process.stdin;
const TrafficLightStory = require('./traffic-light-story');

stdin.setRawMode(true);
stdin.resume();
stdin.setEncoding('utf8');

const trafficLightStory = new TrafficLightStory();

trafficLightStory.tell();

stdin.on('data', key => {
  if ( key === '\u0003' ) {
    process.exit();
  }

  trafficLightStory.requestGreen();
});
```

Вот это уже похоже на human oriented код. Открою один секрет. На самом деле все эти телодвижения по большому счету сводились к получению вот этого кода:

```javascript
  tell() {
    this.recursiveTimer
      .withInitialValue(constants.RED_STATE)
      .withCustomTimeout(this.trafficLight.getNextTimeout)
      .calculateNextValue(this.trafficLight.getNextLight)
      .start(this.trafficLight.setAndShowLight);
  }

  requestGreen() {
    if (this.trafficLight.isRedOrYellowAfterGreen()) {
      this.recursiveTimer.restartFrom(constants.YELLLOW_BEFORE_GREEN_STATE);
    }
  }
```

... самого понятного кода в программе. А сейчас снова окунемся в тайны человеческого мышления и попытаемся ответить на такой вопрос. При каком типе рассуждения процесс логического запомининия проще: когда мы движемся от сложного к простому или наоборот? Я, да и большинство моих читателей скажут, что наоборот и будут совершенно правы. Ведь как декларировалось ранее, человеку проще в один момент выполнять одно задание, воспринимать сложное как множество простого итд. Спорить бесполезно - так устроен наш мир. Так давайте по этим принципам и строить наши проекты, тем более что Project management с его аджайлами-скрамами и итерациями концептуально давно впереди, но все эти знания никак пока напрямую не влияют на код, а только на некоторые условия его создания. А у менеджеров нам есть чему поучиться, поверьте!

Ну а теперь немного замечаний относительно всего решения Светофор.

Не секрет, что в нашей, как и в любой другой программе, есть точка входа. У нас это `index.js`. Он исключительно прост и это правильно, тк смотрите выше :) Все, что есть - это работа с Историей, то есть История - следующая на нашем пути и она может быть чуть сложнее точки входа, но все же должна быть проще, чем Объект или Процесс. Дальше можно заметить, что Объект прост, а Процесс не очень. Но это нормально, поскольку алгоритмическая нагрузка ложится как раз именно на Процесс (хотя и наоборот - тоже может быть правильно). Главное тут не объем кода, а то как четко реализована его идея. И потом, усложнение кода от точки входа - это нормально. Ненормальная ситуация - когда сложная точка входа ведет к простым частям, которых много и непонятно как они связаны.

# POS принцип

(Process - Object - Story)
