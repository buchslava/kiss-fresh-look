## Понятийная простота

Ну вот и дошла очередь до понятийной простоты.
Сразу хочу заметить, что в полном объеме раскрыть эту тему невозможно, поскольку в отличие от структурной простоты, тут неограниченная номенклатура проблем, а следовательно и неограниченное количество их решений.
Но несмотря на это я попытаюсь выделить наиболее характерные решения и на примерах выявить паттерны, которые будут полезны в решении разноплановых задач, а именно задач упрощения кода в понятийном аспекте.

Хочу заострить внимание на том, что в своих рассуждениях я не буду иметь в виду специфические задачи типа
построения UI, работу с базами данный, проектирование сложных многоуровневых систем итд. Причина проста:
решения проблем по вышеперечисленным тематикам и так прекрасно представлены в литературе, видеоуроках, 
научных работах... Одним словом, хорошо изучены. В отличие, кстати, от данной тематики.

Итак, с чем мы имеем дело? Понятно, что не с UI, СУБД и архитектурой многоуровневых системам. Там свои правила игры и толстые умные книги. Макромир, однако!

Тогда с чем же? Да просто с обыкновеннвми прикладными элементарными, казалось бы, задачками, коих в нашем повседневном коде великое множество. Можно сказать, что с микромиром. Именно из этих кирпичиков и состоят реальные проекты. Это может быть например, функционал для работы с бухгалтерской проводкой, части телекоммуникационного биллинга, компоненты обработки банковской или грузовой документации, управление поведением робота, ...

При работе с одним большим проектом я заметил такую специфику: классы и методы названы адекватно, их соподчиненность тоже вопросов не вызывала. И все было хорошо, пока не пришлось начать разбирать по косточкам сам код методов. И когда я залез "в кишки" - код самих методов, стало понятно - что ничего то и непонятно с этим проектом. То есть с макромиром - вшешний порядок, а с микромиром - беда.

Именно такую ситуацию я и считаю наиболее опасной и посвящаю данную работу борьбе с ней.

На самом деле, этот самый микромир в каком-то смысле более важен чем макромир с его архитектурными хитросплетениями. И при этом он менее заметен. Микро же! Рассуждения просты: нельзя построить качественный дом их некачественных кирпичей.

В чем же тут проблема? Казалось бери и пиши. Тем более что backlog готов, заказчик дружелюбен и коллеги умны.
Но нет... На практике часто получается так, что при практически идеальных условиях с проектами возникают проблемы в плане 
простоты кода. Что уж тогда говорить про не совсем или совсем НЕ идеальные услоивия, когда ТЗ противоречиво, времени мало,
планирование и контроль качества отсутствуют.

А что если проект на миллионы строк кода и на годы. Как раз вот тут код и становится тем краеугольным камнем, от
которого и зависит - взлетит проект или пополнит и так уже и без того объемное виртуальное кладбище. То есть, сотни строк плохого кода исправить можно, а миллионы - НЕТ: не помогут ни аджайл ни скрам ни код ревью ни гуру, ни уйма времени. Вы даже не поверите, но и обильные финансовые вливания тоже не помогут... 

А может вообще лучше ничего не исправлять, а писать сразу просто. Фантастика? Думаю, что нет...

Хватит лирики, перейдем к примеру. В качестве самого простого прикладного примера я выбрал "Светофор". Итак задача. Написать программу, выдающую сигналы цвета (красный - желтый - зеленый - желтый - ...) во времени. Причем интервал для желтого меньше интервала для красного и зеленого. Плюс дополнительный функционал так радующий пешехода и раздражающий водителя. Это возможность быстрого переключения на зеленый свет по требованию. Наверное, более детальнаое описание этого функционала не требуется...

Для начала напишем неполный минимальный пример:

`/00sketch.js`
```javascript
const lights = ['red', 'yellow', 'green', 'yellow'];

const timeout = (currentLight) => {
  const nextLight = currentLight + 1 < lights.length ? currentLight + 1 : 0;
  const timeoutValue = nextLight === 1 || nextLight === 3 ? 500 : 3000;

  setTimeout(() => {
    console.log(lights[currentLight], new Date());

    timeout(nextLight);
  }, timeoutValue);
}

timeout(0);
```

Поясню.

Вот минимальная последовательность состояний с учетом нужного порядка:
```javascript
const lights = ['red', 'yellow', 'green', 'yellow'];
```
Те красный(0) - желтый(1) - зеленый(2) - желтый(3) ... итд.

Далее определим функцию `timeout`, в которой и будет содержаться логика работы светофора.

```javascript
// на вход поступает текущий свет, определяющийся как соответствующая позиция
// массива lights
const timeout = (currentLight) => {
  // определим следующий свет как текущий свет+1, те следующий в массиве lights
  // или 0 - (те с начала) если достигнут конец массива
  const nextLight = currentLight + 1 < lights.length ? currentLight + 1 : 0;
  // определим значение timeout:
  // если текущий свет желтый - то 500ms, а иначе 3sec
  const timeoutValue = nextLight === 1 || nextLight === 3 ? 500 : 3000;

  // установим таймаут
  setTimeout(() => {
    // а в нем выведем на экран текущий свет
    console.log(lights[currentLight], new Date());

    // и после этого рекурсивно вызовем эту же функцию, 
    // только уже новым значением света
    timeout(nextLight);
  }, timeoutValue);
}
```
Ну и наконец, сам запуск:

```javascript
timeout(0);
```

Обратите внимание на значение парамерта функции: 0 - красный. Тут мог быть и любой другой цвет от 0 до 3.

Запустим: `node ./00sketch.js` и после некоторого времени работы и Ctrl+C получим примерно такой результат:
```
red 2017-09-24T16:30:35.180Z
yellow 2017-09-24T16:30:38.190Z
green 2017-09-24T16:30:38.692Z
yellow 2017-09-24T16:30:41.697Z
red 2017-09-24T16:30:42.199Z
yellow 2017-09-24T16:30:45.204Z
green 2017-09-24T16:30:45.706Z
yellow 2017-09-24T16:30:48.712Z
red 2017-09-24T16:30:49.212Z
yellow 2017-09-24T16:30:52.218Z
green 2017-09-24T16:30:52.720Z
yellow 2017-09-24T16:30:55.724Z
red 2017-09-24T16:30:56.226Z
yellow 2017-09-24T16:30:59.226Z
green 2017-09-24T16:30:59.728Z
``` 

Теперь самое время добавить обещанный функционал "Зелёный по требованию": `01simple.js`

```javascript
const stdin = process.stdin;

stdin.setRawMode(true);
stdin.resume();
stdin.setEncoding('utf8');

const lights = ['red', 'yellow', 'green', 'yellow'];

let globalCurrentLight = 0;
let globalTimeout = null;

const timeout = (currentLight) => {
  const nextLight = currentLight + 1 < lights.length ? currentLight + 1 : 0;
  const timeoutValue = nextLight === 0 || nextLight === 2 ? 2000 : 5000;

  globalCurrentLight = currentLight;

  console.log(lights[currentLight], new Date());

  globalTimeout = setTimeout(() => {
      timeout(nextLight);
  }, timeoutValue);
};

stdin.on('data', key => {
  if ( key === '\u0003' ) {
    process.exit();
  }

  if (globalCurrentLight === 0 || globalCurrentLight === 3) {
    clearTimeout(globalTimeout);

    timeout(1);
  }
});

timeout(0);
```

Хоть и данный пример не был радикально изменен по-сравнению с предыдущим, все же требуются небольшие пояснения.
Итак, код пусть вас не смущает
```javascript
const stdin = process.stdin;

stdin.setRawMode(true);
stdin.resume();
stdin.setEncoding('utf8');
```
примете его просто как данное.

А вот этот код уже куда поважнее для нашей задачи:

```javascript
let globalCurrentLight = 0;
let globalTimeout = null;
```

Все дело в том, что в предыдущем примере текущее значение света и таймаут были инкапсулированы внутри функции `timeout`. А в данном примере эти параметры надо менять извне. И вот поэтому и были добавлены две глобальные переменные. Тут опытному читателю время возмутиться и высказать претензии, кстати, совершенно справедливые... Немного терпения, дорогой читатель! Во-первых я хочу показать не только как надо писать код, но и как этого делать НЕ надо. Во-вторых хочется продемонстрировать полный процесс эволюции: от простого и неаккуратного к сложному и гармоничному. Ну а в-третьих - цель этой работы - больше чем просто написание кода. Тут речь пойдет о приобретении особого мировоззрения: не больше и не меньше.

Итак, в функции `timeout` изменений немного:
```javascript
const timeout = (currentLight) => {
  const nextLight = currentLight + 1 < lights.length ? currentLight + 1 : 0;
  const timeoutValue = nextLight === 0 || nextLight === 2 ? 2000 : 5000;

  // сохраним глобальное состояние
  globalCurrentLight = currentLight;

  console.log(lights[currentLight], new Date());

  globalTimeout = setTimeout(() => {
      timeout(nextLight);
  }, timeoutValue);
};
```

А вот с новым кодом будет веселей:

```javascript
// читаем поток ввода: клавиатуру
stdin.on('data', key => {
  // если это Ctrl+C
  if ( key === '\u0003' ) {
    // завершаем программу 
    process.exit();
  }

  // если это любая другая клавиша или комбинация
  // и при этом текущий свет красный или желтый перед красным
  if (globalCurrentLight === 0 || globalCurrentLight === 3) {
    // отменяем текуший таймаут
    clearTimeout(globalTimeout);

    // и стартуем процесс с желтого света, только того, который перед зеленым
    timeout(1);
  }
});
```

Запустим: `node ./01simple.js` и после некоторого времени работы и Ctrl+C получим примерно такой результат:
```
red 2017-09-24T19:58:46.247Z
yellow 2017-09-24T19:58:51.255Z
green 2017-09-24T19:58:53.256Z
yellow 2017-09-24T19:58:58.262Z
red 2017-09-24T19:59:00.268Z
yellow 2017-09-24T19:59:00.782Z
green 2017-09-24T19:59:02.787Z
yellow 2017-09-24T19:59:07.793Z
yellow 2017-09-24T19:59:08.402Z
green 2017-09-24T19:59:10.408Z
yellow 2017-09-24T19:59:15.414Z
red 2017-09-24T19:59:17.419Z
yellow 2017-09-24T19:59:17.940Z
green 2017-09-24T19:59:19.942Z
```

На приведенном выше результате видно, где была нажата кнопка "Зеленвй по требованию". Это где желтый свет идет подряд и интервал между красным и желтым менее 3-х секунд.

Теперь самое время критически взглануть на `01simple.js`. Главная проблема этого кода - глобальные состояния. Такое недопустимо даже в рамках студенческих лабораторных работ. Вторая проблема менее очевидна для неподготовленного разработчика. Это слабая структурированность кода. Да, да - это отсутствие той самой структурной простоты, о которую я упоминал в самом начале. Дело в том, что это нам, читателям, ясно что речь идет о светофоре. А если показать этот код другим разработчикам? Поймут? Нет! В лучшем случае догадаются опираясь на личный опыт. И как тут не вспомнить о эгоцентричности в восприятии простоты!!!

Итак, встречайте `02oop.js`
```javascript
const stdin = process.stdin;

stdin.setRawMode(true);
stdin.resume();
stdin.setEncoding('utf8');

class TrafficLight {
  constructor() {
    this.RED = Symbol('RED');
    this.YELLOW = Symbol('YELLOW');
    this.GREEN = Symbol('GREEN');

    this.lights = [this.RED, this.YELLOW, this.GREEN, this.YELLOW];
    this.currentLight = 0;
    this.timeoutId = null;
  }

  process(currentLight) {
    this.currentLight = currentLight;

    const nextLight = this.currentLight + 1 < this.lights.length ? this.currentLight + 1 : 0;
    const timeoutValue = nextLight === 0 || nextLight === 2 ? 2000 : 5000;

    console.log(String(this.lights[currentLight]), new Date());

    clearTimeout(this.globalTimeout);

    this.globalTimeout = setTimeout(() => {
        this.process(nextLight);
    }, timeoutValue);
  }

  greenRequest() {
    if (this.currentLight === 0 || this.currentLight === 3) {
      clearTimeout(this.globalTimeout);

      this.process(1);
    }
  }
}

const trafficLight = new TrafficLight();

trafficLight.process(0);

stdin.on('data', key => {
  if ( key === '\u0003' ) {
    process.exit();
  }

  trafficLight.greenRequest();
});
```

Как вы уже заметили, принципиальное отличие данного примера от всех предыдущих заключается в использовании ООП. В данном случае это нужно прежде всего для инкапсуляции понятия "Светофор" и как следствия - избавления от глобальных состояний.

















после этого рассказать о ЕЯ и разгромить сущ парадигму
+история - smalltalk, провал...мейнстрим

