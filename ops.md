## Понятийная простота

Ну вот и дошла очередь до понятийной простоты.
Сразу хочу заметить, что в полном объеме раскрыть эту тему невозможно, поскольку в отличие от структурной простоты, тут неограниченная номенклатура проблем, а следовательно и неограниченное количество их решений.
Но несмотря на это я попытаюсь выделить наиболее характерные решения и на примерах выявить паттерны, которые будут полезны в решении разноплановых задач, а именно задач упрощения кода в понятийном аспекте.

Хочу заострить внимание на том, что в своих рассуждениях я не буду иметь в виду специфические задачи типа
построения UI, работу с базами данный, проектирование сложных многоуровневых систем итд. Причина проста:
решения проблем по вышеперечисленным тематикам и так прекрасно представлены в литературе, видеоуроках, 
научных работах... Одним словом, хорошо изучены. В отличие, кстати, от данной тематики.

Итак, с чем мы имеем дело? Понятно, что не с UI, СУБД и архитектурой многоуровневых системам. Там свои правила игры и толстые умные книги. Макромир, однако!

Тогда с чем же? Да просто с обыкновеннвми прикладными элементарными, казалось бы, задачками, коих в нашем повседневном коде великое множество. Можно сказать - с микромиром. Именно из этих кирпичиков и состоят проекты. Это может быть например, функционал для работы с бухгалтерской проводкой, части телекоммуникационного биллинга, компоненты обработки банковской или грузовой документации, управление поведением робота, ...

На самом деле, этот самый микромир в каком-то смысле более важен чем макромир с его архитектурными хитросплетениями. И при этом он менее заметен. Микро же! Рассуждения просты: нельзя построить качественный дом их некачественных кирпичей.

В чем же тут проблема? Казалось бери и пиши. Тем более что backlog готов, заказчик дружелюбен и коллеги умны.
Но нет... На практике часто получается так, что при практически идеальных условиях с проектами возникают проблемы в плане 
простоты кода. Что уж тогда говорить про не совсем или совсем НЕ идеальные услоивия, когда ТЗ противоречиво, времени мало,
планирование и контроль качества отсутствуют.

А что если проект на миллионы строк кода и на годы. Как раз вот тут код и становится тем краеугольным камнем, от
которого и зависит - взлетит проект или пополнит и так уже и без того объемное виртуальное кладбище. То есть, сотни строк плохого кода исправить можно, а миллионы - НЕТ - не помогут ни аджайл ни скрам ни код ревью ни гуру,ни уйма времени. Вы даже не поверите, но и обильные финансовые вливания тоже не помогут. А может вообще лучше ничего не исправлять, а писать сразу просто. Фантастика? Думаю, что нет...

Хватит лирики, перейдем к примеру. В качестве самого простого прикладного примера я выбрал "Светофор". Итак задача. Написать программу, выдающую сигналы цвета (красный - желтый - зеленый - желтый - ...) во времени. Причем интервал для желтого меньше интервала для красного и зеленого. Плюс дополнительный функционал так радующий пешехода и раздражающий водителя. Это возможность быстрого переключения на зеленый свет по требованию. Наверное, более детальнаое описание этого функционала не требуется...

Вот самый простой вариант решения даннной задачи:

`traffic-light-simple.js`

```
```

Небольшие пояснения



------

после этого рассказать о ЕЯ и разгромить сущ парадигму
+история - smalltalk, провал...мейнстрим


```javascript
class TrafficLight {
  constructor() {
    this.RED = Symbol('RED');
    this.YELLOW = Symbol('YELLOW');
    this.GREEN = Symbol('GREEN');

    this.lights = [this.RED, this.YELLOW, this.GREEN, this.YELLOW];
    this.currentLight = 0;
    this.timeoutId = null;
  }

  process(currentLight) {
    this.currentLight = currentLight;

    const nextLight = this.currentLight + 1 < this.lights.length ? this.currentLight + 1 : 0;
    const nextTimeout = nextLight === 0 || nextLight === 2 ? 2000 : 5000;

    console.log(String(this.lights[currentLight]));

    clearTimeout(this.globalTimeout);

    this.globalTimeout = setTimeout(() => {
        this.process(nextLight);
    }, nextTimeout);
  }
}

const trafficLight = new TrafficLight();

trafficLight.process(0);
```